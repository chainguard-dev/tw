package helm

import (
	"archive/tar"
	"compress/gzip"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
)

func TestHelmCommand(t *testing.T) {
	testCases := []struct {
		name        string
		args        []string
		expected    *helmOpts
		expectError bool
	}{
		{
			name: "basic install",
			args: []string{"helm", "install", "my-release", "my/chart"},
			expected: &helmOpts{
				op:        "install",
				name:      "my-release",
				chart:     "my/chart",
				namespace: "default",
				values:    []string{},
			},
			expectError: false,
		},
		{
			name: "install with flags",
			args: []string{"helm", "install", "release", "repo/chart", "--repo", "https://charts.example.com", "--namespace", "prod", "--version", "1.2.3", "-f", "values.yaml", "--values", "more-values.yaml"},
			expected: &helmOpts{
				op:        "install",
				name:      "release",
				chart:     "repo/chart",
				repo:      "https://charts.example.com",
				namespace: "prod",
				version:   "1.2.3",
				values:    []string{"values.yaml", "more-values.yaml"},
			},
			expectError: false,
		},
		{
			name: "upgrade command",
			args: []string{"helm", "upgrade", "existing", "stable/nginx", "--version", "1.0.0"},
			expected: &helmOpts{
				op:        "upgrade",
				name:      "existing",
				chart:     "stable/nginx",
				namespace: "default",
				version:   "1.0.0",
				values:    []string{},
			},
			expectError: false,
		},
		{
			name:        "invalid operation",
			args:        []string{"helm", "delete", "my-release"},
			expectError: true,
		},
		{
			name: "unusual but valid argument order",
			args: []string{"helm", "install", "--version", "1.0.0", "--namespace", "test", "my-release", "my/chart"},
			expected: &helmOpts{
				op:        "install",
				name:      "my-release",
				chart:     "my/chart",
				namespace: "test",
				version:   "1.0.0",
				values:    []string{},
			},
			expectError: false,
		},
		{
			name:        "missing release name",
			args:        []string{"helm", "install"},
			expectError: true,
		},
		{
			name:        "missing chart",
			args:        []string{"helm", "install", "my-release"},
			expectError: true,
		},
		{
			name: "install with generate-name",
			args: []string{"helm", "install", "--generate-name", "my/chart"},
			expected: &helmOpts{
				op:        "install",
				name:      "", // Name will be generated by Helm
				chart:     "my/chart",
				namespace: "default",
				values:    []string{},
			},
			expectError: false,
		},
		{
			name: "install from local chart",
			args: []string{"helm", "install", "my-release", "./local-chart-path"},
			expected: &helmOpts{
				op:        "install",
				name:      "my-release",
				chart:     "./local-chart-path",
				namespace: "default",
				repo:      "", // Empty repo indicates a local chart
				values:    []string{},
			},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			opts, err := helmCommand(tc.args...)

			// Check error expectations
			if tc.expectError {
				if err == nil {
					t.Errorf("Expected error but got nil")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if diff := cmp.Diff(tc.expected, opts, cmpopts.IgnoreUnexported(helmOpts{})); diff != "" {
				t.Errorf("helmCommand() mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func TestAttest(t *testing.T) {
	// Create a temporary directory for our test files
	tempDir := t.TempDir()

	// Create some test values files
	values1Content := "foo: bar\nbaz: qux\n"
	values1Path := filepath.Join(tempDir, "values1.yaml")
	if err := os.WriteFile(values1Path, []byte(values1Content), 0644); err != nil {
		t.Fatalf("Failed to create values file: %v", err)
	}

	values2Content := "foo: override\nkey: value\n"
	values2Path := filepath.Join(tempDir, "values2.yaml")
	if err := os.WriteFile(values2Path, []byte(values2Content), 0644); err != nil {
		t.Fatalf("Failed to create values file: %v", err)
	}

	emptyValuesPath := filepath.Join(tempDir, "empty.yaml")
	if err := os.WriteFile(emptyValuesPath, []byte(""), 0644); err != nil {
		t.Fatalf("Failed to create empty values file: %v", err)
	}

	// Create a test chart
	chartName := "test-chart"
	chartVersion := "1.2.3"
	chartPath := createTestChart(t, tempDir, chartName, chartVersion)

	dirChartName := "dir-chart"
	dirChartVersion := "2.0.0"
	dirChartPath := createDirectoryChart(t, tempDir, dirChartName, dirChartVersion)

	testCases := []struct {
		name          string
		chartPath     string
		hopts         *helmOpts
		configValues  []string
		expectedChart InventoryChartInfo
		expectedVals  map[string]interface{}
		expectError   bool
	}{
		{
			name:      "basic attestation no values",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{}, // No values specified
			},
			configValues: []string{}, // No values allowed
			expectedChart: InventoryChartInfo{
				Name:       chartName,
				Version:    chartVersion,
				Repository: "https://charts.example.com",
				// Digest will be checked separately
			},
			expectedVals: map[string]interface{}{},
			expectError:  false,
		},
		{
			name:      "directory chart",
			chartPath: dirChartPath,
			hopts: &helmOpts{
				chart:   dirChartName,
				version: dirChartVersion,
				repo:    "", // Empty repo indicates local chart
				values:  []string{},
			},
			configValues: []string{},
			expectedChart: InventoryChartInfo{
				Name:       dirChartName,
				Version:    dirChartVersion,
				Repository: "",
				Local:      true,
			},
			expectedVals: map[string]interface{}{},
			expectError:  false,
		},
		{
			name:      "attestation with non-allowed values",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{values1Path}, // Values specified in helm command
			},
			configValues: []string{}, // But none allowed by attestor config
			expectedChart: InventoryChartInfo{
				Name:       chartName,
				Version:    chartVersion,
				Repository: "https://charts.example.com",
			},
			expectedVals: map[string]interface{}{}, // Empty since no values are allowed
			expectError:  false,
		},
		{
			name:      "attestation with allowed values",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{values1Path, values2Path}, // Both values specified
			},
			configValues: []string{values1Path, values2Path}, // Both allowed
			expectedChart: InventoryChartInfo{
				Name:       chartName,
				Version:    chartVersion,
				Repository: "https://charts.example.com",
			},
			expectedVals: map[string]interface{}{
				"foo": "override", // From values2 (override)
				"baz": "qux",      // From values1
				"key": "value",    // From values2
			},
			expectError: false,
		},
		{
			name:      "attestation with partial allowed values",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{values1Path, values2Path}, // Both specified
			},
			configValues: []string{values1Path}, // Only values1 allowed
			expectedChart: InventoryChartInfo{
				Name:       chartName,
				Version:    chartVersion,
				Repository: "https://charts.example.com",
			},
			expectedVals: map[string]interface{}{
				"foo": "bar", // From values1 only
				"baz": "qux", // From values1 only
			},
			expectError: false,
		},
		{
			name:      "attestation with nonexistent values file",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{"nonexistent.yaml"},
			},
			configValues: []string{"nonexistent.yaml"}, // Allowed but doesn't exist
			expectError:  true,
		},
		{
			name:      "attestation with corrupted chart",
			chartPath: values1Path, // Not a valid chart file
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
			},
			expectError: true,
		},
		{
			name:      "empty values file",
			chartPath: chartPath,
			hopts: &helmOpts{
				chart:   chartName,
				version: chartVersion,
				repo:    "https://charts.example.com",
				values:  []string{emptyValuesPath}, // Create an empty file first
			},
			configValues: []string{emptyValuesPath},
			expectedChart: InventoryChartInfo{
				Name:       chartName,
				Version:    chartVersion,
				Repository: "https://charts.example.com",
			},
			expectedVals: map[string]interface{}{},
			expectError:  false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctx := context.Background()
			cfg := &cmdConfig{
				values: tc.configValues,
			}

			att, err := cfg.inventory(ctx, tc.chartPath, tc.hopts)

			// Check error expectations
			if tc.expectError {
				if err == nil {
					t.Errorf("Expected error but got nil")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			// Check Chart info excluding Digest which is dynamically computed
			opts := cmpopts.IgnoreFields(InventoryChartInfo{}, "Digest")
			if diff := cmp.Diff(tc.expectedChart, att.Chart, opts); diff != "" {
				t.Errorf("Chart info mismatch (-want +got):\n%s", diff)
			}

			if !tc.expectedChart.Local {
				// Ensure digest is properly formatted
				if !strings.HasPrefix(att.Chart.Digest, "sha256:") {
					t.Errorf("Expected digest to start with 'sha256:', got %q", att.Chart.Digest)
				}
				if len(att.Chart.Digest) != len("sha256:")+64 {
					t.Errorf("Digest has wrong length. Expected %d characters (sha256: + 64 hex chars), got %d: %s",
						len("sha256:")+64, len(att.Chart.Digest), att.Chart.Digest)
				}
			}

			// Check values
			vals, ok := att.Values.(map[string]interface{})
			if !ok {
				t.Fatalf("Expected Values to be map[string]interface{}, got %T", att.Values)
			}

			if diff := cmp.Diff(tc.expectedVals, vals); diff != "" {
				t.Errorf("Values mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func createTestChart(t *testing.T, dir, name, version string) string {
	t.Helper()

	filename := filepath.Join(dir, fmt.Sprintf("%s-%s.tgz", name, version))
	f, err := os.Create(filename)
	if err != nil {
		t.Fatalf("Failed to create test chart file: %v", err)
	}
	defer f.Close()

	gw := gzip.NewWriter(f)
	defer gw.Close()
	tw := tar.NewWriter(gw)
	defer tw.Close()

	// Create Chart.yaml content
	chartYaml := fmt.Sprintf(`
apiVersion: v2
name: %s
version: %s
description: Test chart for unit tests
`, name, version)

	// Write Chart.yaml to the tarball
	chartYamlHeader := &tar.Header{
		Name: fmt.Sprintf("%s/Chart.yaml", name),
		Mode: 0644,
		Size: int64(len(chartYaml)),
	}

	if err := tw.WriteHeader(chartYamlHeader); err != nil {
		t.Fatalf("Failed to write chart header: %v", err)
	}

	if _, err := tw.Write([]byte(chartYaml)); err != nil {
		t.Fatalf("Failed to write chart content: %v", err)
	}

	// Properly close writers
	if err := tw.Close(); err != nil {
		t.Fatalf("Failed to close tar writer: %v", err)
	}
	if err := gw.Close(); err != nil {
		t.Fatalf("Failed to close gzip writer: %v", err)
	}
	if err := f.Close(); err != nil {
		t.Fatalf("Failed to close file: %v", err)
	}

	return filename
}

func createDirectoryChart(t *testing.T, dir, name, version string) string {
	t.Helper()

	// Create chart directory
	chartDir := filepath.Join(dir, name)
	if err := os.Mkdir(chartDir, 0755); err != nil {
		t.Fatalf("Failed to create chart directory: %v", err)
	}

	// Create Chart.yaml content
	chartYaml := fmt.Sprintf(`
apiVersion: v2
name: %s
version: %s
description: Test chart for unit tests
`, name, version)

	// Write Chart.yaml to the directory
	chartYamlPath := filepath.Join(chartDir, "Chart.yaml")
	if err := os.WriteFile(chartYamlPath, []byte(chartYaml), 0644); err != nil {
		t.Fatalf("Failed to write Chart.yaml: %v", err)
	}

	return chartDir
}
